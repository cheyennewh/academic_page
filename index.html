<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Chey Wakeland-Hart - Cognitive Scientist</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    font-family:'Georgia',serif; line-height:1.6; color:#333;
    background:#0e0f14; /* will be covered by canvas; fallback color */
    min-height:100vh;
  }

  /* === GLOBAL PARTICLE BACKGROUND (canvas) === */
  #bg-canvas{
    position:fixed; inset:0;
    z-index:-2;         /* behind everything */
    pointer-events:none;/* click-through */
    display:block;
  }
 .header{
   background: 
     radial-gradient(1200px 600px at 10% 20%, #1b1e26 0%, transparent 60%),
     radial-gradient(900px 500px at 85% 30%, #0f1116 0%, transparent 55%),
     conic-gradient(from 240deg at 60% 60%, #0f1116 0%, #171921 30%, #0f1116 60%, #171921 85%, #0f1116 100%),
     #14161c; /* base */
   color:#fff;
   position:relative;
   overflow:hidden;
   isolation:isolate;
 }
 .header::after{
  content:"";
  position:absolute; inset:0;
  pointer-events:none;
  box-shadow: inset 0 0 200px 120px rgba(0,0,0,0.6);
  z-index:0;
}
.header::before{
  content:"";
  position:absolute; inset:0; z-index:0; pointer-events:none;
  opacity:.05;         /* 0.03–0.08 */
  mix-blend-mode:overlay;
  background-image:url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160'>\
<filter id='n'><feTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='4' stitchTiles='stitch'/></filter>\
<rect width='100%' height='100%' filter='url(#n)'/>\
</svg>");
  background-size: 240px 240px; /* scale grain */
}
/* sits between background and content */
.header .blur-overlay{
  position:absolute; inset:0; z-index:0; pointer-events:none;
  background: rgba(20,22,28,0.4);      /* tint */
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
  border-bottom: 1px solid rgba(255,255,255,0.04); /* subtle rim light */
}

  /* === HEADER with neuron SVG background === */
  .container{max-width:1200px;margin:0 auto; background:rgba(255,255,255,0.95);
    backdrop-filter:blur(10px); border-radius:20px; box-shadow:0 20px 40px rgba(0,0,0,.1);
    margin-top:2rem; margin-bottom:2rem; overflow:hidden;
  }
  .header{
    background:#14161c;           /* your requested header color */
    color:#fff; padding:3rem 2rem; text-align:center;
    position:relative; overflow:hidden; isolation:isolate;
  }
  /* neuron svg sits under header content */
  #neuron-header-bg{
    position:absolute; inset:0; z-index:0; pointer-events:none; opacity:.35;
  }
  #neuron-header-bg svg{width:100%;height:100%;display:block}

  .profile-content{position:relative; z-index:1}
  .profile-img{width:200px;height:200px;border-radius:50%;border:5px solid rgba(255,255,255,.2);
    margin:0 auto 2rem; background:#ddd; display:flex;align-items:center;justify-content:center;
    font-size:3rem;color:#999;
  }

  .nav{background:rgba(52,73,94,.1); padding:0; display:flex; justify-content:center; flex-wrap:wrap;
    border-bottom:1px solid rgba(0,0,0,.1)}
  .nav a{padding:1rem 2rem; text-decoration:none; color:#2c3e50; font-weight:500; transition:.3s; position:relative}
  .nav a:hover,.nav a.active{background:#3498db;color:#fff}
  .nav a::after{content:''; position:absolute; bottom:0; left:50%; width:0; height:3px; background:#3498db;
    transition:.3s; transform:translateX(-50%)}
  .nav a:hover::after{width:100%}

  .content{padding:3rem 2rem}
  .section{display:none; animation:fadeIn .5s ease}
  .section.active{display:block}
  @keyframes fadeIn{from{opacity:0;transform:translateY(20px)} to{opacity:1;transform:translateY(0)}}
  .section h2{color:#2c3e50; margin-bottom:2rem; font-size:2rem; position:relative; padding-bottom:.5rem}
  .section h2::after{content:''; position:absolute; bottom:0; left:0; width:50px; height:3px;
    background:linear-gradient(135deg,#3498db,#9b59b6); border-radius:2px}

  .research-item,.teaching-item,.presentation-item{
    background:rgba(255,255,255,.8); padding:2rem; margin-bottom:2rem; border-radius:15px;
    border-left:5px solid #3498db; box-shadow:0 5px 15px rgba(0,0,0,.1); transition:.3s
  }
  .research-item:hover,.teaching-item:hover,.presentation-item:hover{
    transform:translateY(-5px); box-shadow:0 10px 25px rgba(0,0,0,.15)
  }
  .btn{display:inline-block; padding:.75rem 2rem; background:linear-gradient(135deg,#3498db,#9b59b6);
    color:#fff; text-decoration:none; border-radius:25px; font-weight:500; transition:.3s; margin-top:1rem}
  .btn:hover{transform:translateY(-2px); box-shadow:0 5px 15px rgba(0,0,0,.2)}

  /* optional motion respect */
  @media (prefers-reduced-motion: reduce){
    #neuron-header-bg .pulsePath{ animation-duration:12s !important }
  }

  @media (max-width:768px){
    .container{margin:1rem;border-radius:15px}
    .profile-img{width:150px;height:150px}
  }
</style>
</head>
<body>

<!-- GLOBAL PARTICLE BACKGROUND -->
<canvas id="bg-canvas"></canvas>

<div class="container">
  <header class="header">
    <!-- Neuron SVG lives INSIDE header -->
    <div id="neuron-header-bg" aria-hidden="true"></div>
<header class="header">
  <div id="neuron-header-bg" aria-hidden="true"></div>
  <div class="blur-overlay" aria-hidden="true"></div>
  <div class="profile-content"> … </div>
</header>

    <div class="profile-content">
      <div class="profile-img"><i class="fas fa-user"></i></div>
      <h1 class="name">Your Name</h1>
      <p class="title">Doctoral Researcher in Cognitive Neuroscience</p>
      <p>Columbia University Psychology Department</p>
      <div class="social-links">
        <a href="mailto:your.email@columbia.edu" title="Email"><i class="fas fa-envelope"></i></a>
        <a href="#" title="LinkedIn"><i class="fab fa-linkedin"></i></a>
        <a href="#" title="Google Scholar"><i class="fas fa-graduation-cap"></i></a>
        <a href="#" title="ORCID"><i class="fab fa-orcid"></i></a>
        <a href="#" title="GitHub"><i class="fab fa-github"></i></a>
      </div>
    </div>
  </header>

  <nav class="nav">
    <a href="#about" class="nav-link active" onclick="showSection(event,'about')">About</a>
    <a href="#research" class="nav-link" onclick="showSection(event,'research')">Research</a>
    <a href="#teaching" class="nav-link" onclick="showSection(event,'teaching')">Teaching</a>
    <a href="#presentations" class="nav-link" onclick="showSection(event,'presentations')">Presentations</a>
    <a href="#skills" class="nav-link" onclick="showSection(event,'skills')">Skills</a>
    <a href="#contact" class="nav-link" onclick="showSection(event,'contact')">Contact</a>
  </nav>

  <main class="content">
    <section id="about" class="section active">
      <h2>About Me</h2>
      <p>…</p>
      <a href="#" class="btn">Download CV</a>
    </section>
    <!-- other sections ... -->
  </main>
</div>

<script>
/* ======= NAV ======= */
function showSection(e, id){
  document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  document.querySelectorAll('.nav-link').forEach(a=>a.classList.remove('active'));
  e.target.classList.add('active');
}

/* =========================================================
   1) GLOBAL PARTICLE BACKGROUND (your code, fixed + HiDPI)
   ========================================================= */
(() => {
  let w,h,loopId,ctx,particles=[], dpr = Math.max(1, Math.round(window.devicePixelRatio||1));
  const canvas = document.getElementById('bg-canvas');

  const options = {
    particleColor: "rgba(255,255,255,0.9)",
    lineColor: "rgba(0,181,255,1)",
    particleAmount: 60,
    defaultRadius: 2,
    variantRadius: 2,
    defaultSpeed: .05,
    variantSpeed: .05,
    linkRadius: 180
  };
  const rgb = options.lineColor.match(/\d+/g);

  class Particle{
    constructor(){
      this.reset();
      this.radius = options.defaultRadius + Math.random()*options.variantRadius;
      this.speed  = options.defaultSpeed  + Math.random()*options.variantSpeed;
      this.directionAngle = Math.random()*Math.PI*2;
      this.vector = { x: Math.cos(this.directionAngle)*this.speed,
                      y: Math.sin(this.directionAngle)*this.speed };
      this.color = options.particleColor;
    }
    reset(){
      this.x = Math.random()*w;
      this.y = Math.random()*h;
    }
    border(){
      if(this.x>=w||this.x<=0) this.vector.x*=-1;
      if(this.y>=h||this.y<=0) this.vector.y*=-1;
      this.x = Math.max(0,Math.min(w,this.x));
      this.y = Math.max(0,Math.min(h,this.y));
    }
    update(){ this.border(); this.x+=this.vector.x; this.y+=this.vector.y; }
    draw(){
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.closePath();
      ctx.fillStyle = this.color;
      ctx.fill();
    }
  }

  function resize(){
    // CSS size in CSS px
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    canvas.width  = cssW * dpr;
    canvas.height = cssH * dpr;
    canvas.style.width  = cssW + 'px';
    canvas.style.height = cssH + 'px';
    ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    w = cssW; h = cssH;
  }

  function init(){
    resize();
    particles = [];
    for(let i=0;i<options.particleAmount;i++) particles.push(new Particle());
    cancelAnimationFrame(loopId);
    loop();
  }

  function loop(){
    ctx.clearRect(0,0,w,h);
    drawLines();
    particles.forEach(p=>{ p.update(); p.draw(); });
    loopId = requestAnimationFrame(loop);
  }

  function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }
  function drawLines(){
    for(let i=0;i<particles.length;i++){
      for(let j=i+1;j<particles.length;j++){
        const d = dist(particles[i].x,particles[i].y, particles[j].x,particles[j].y);
        const opacity = 1 - d/options.linkRadius;
        if(opacity>0){
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${opacity})`;
          ctx.beginPath();
          ctx.moveTo(particles[i].x,particles[i].y);
          ctx.lineTo(particles[j].x,particles[j].y);
          ctx.stroke();
        }
      }
    }
  }

  window.addEventListener('resize', init, {passive:true});
  init();
})();

/* =========================================================
   2) NEURON SVG INSIDE HEADER ONLY (compact version)
   ========================================================= */
(() => {
  const mount = document.getElementById('neuron-header-bg');
  const NEON='#14e6ff', SOFT='#7ffaff', PULSE='#fff';
  const CFG = { somaCount: 8, minWalks: 5, extraWalkProb:.25,
                step: 28, jitter: Math.PI/6, branches: 8, pulseSec: 5,
                margin: 6, maxMain: 160, maxBranch: 110 };
  const R = (a,b)=>a+(b-a)*Math.random();

  function buildSVG(W,H){
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
    svg.innerHTML = `
      <defs>
        <filter id="glow-soft" x="-40%" y="-40%" width="180%" height="180%">
          <feGaussianBlur stdDeviation="4" result="b1"/><feMerge>
            <feMergeNode in="b1"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
        <filter id="glow-strong" x="-40%" y="-40%" width="180%" height="180%">
          <feGaussianBlur stdDeviation="5" result="b1"/>
          <feGaussianBlur stdDeviation="10" result="b2"/><feMerge>
            <feMergeNode in="b2"/><feMergeNode in="b1"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
        <filter id="glow-pulse" x="-40%" y="-40%" width="180%" height="180%">
          <feGaussianBlur stdDeviation="2" result="b1"/><feMerge>
            <feMergeNode in="b1"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
      </defs>
      <g id="branches"></g><g id="main"></g><g id="pulses"></g><g id="somas"></g>
      <style>
        .soma{fill:${NEON};opacity:1;filter:url(#glow-strong)}
        .soma-core{fill:${NEON};opacity:1;filter:url(#glow-soft)}
        .fiber{fill:${NEON};opacity:.85;filter:url(#glow-soft)}
        .fiber.inner{fill:${SOFT};opacity:.7}
        .pulsePath{
          stroke:${PULSE}; stroke-width:2; fill:none; stroke-linecap:round;
          stroke-dasharray:120 720; animation:flow ${CFG.pulseSec}s linear infinite;
          filter:url(#glow-pulse); opacity:.85; mix-blend-mode:screen;
        }
        @keyframes flow{from{stroke-dashoffset:0} to{stroke-dashoffset:-840}}
      </style>`;
    mount.innerHTML=''; mount.appendChild(svg);
    return {
      svg,
      LAYER_BRANCH: svg.querySelector('#branches'),
      LAYER_MAIN:   svg.querySelector('#main'),
      LAYER_PULSE:  svg.querySelector('#pulses'),
      LAYER_SOMA:   svg.querySelector('#somas')
    };
  }

  const inB=(W,H,x,y,m)=>x>m&&x<W-m&&y>m&&y<H-m;
  const stepFn=(W,H,m,x,y,a,l)=>({x:Math.max(m,Math.min(W-m,x+Math.cos(a)*l)),
                                   y:Math.max(m,Math.min(H-m,y+Math.sin(a)*l))});
  function angles(n,sep=Math.PI/6){const out=[];while(out.length<n){const a=Math.random()*Math.PI*2;
    if(out.every(b=>Math.abs(Math.atan2(Math.sin(a-b),Math.cos(a-b)))>=sep))out.push(a);}return out;}

  function somaPath(cx,cy,baseR=20,arms=8,irr=.5){
    const P=[]; for(let i=0;i<arms;i++){const a=i/arms*2*Math.PI+R(-.12,.12);
      const r=baseR*(1+R(-irr,irr)); P.push([cx+Math.cos(a)*r,cy+Math.sin(a)*r]);}
    const d=[]; for(let i=0;i<P.length;i++){
      const p0=P[(i-1+P.length)%P.length],p1=P[i],p2=P[(i+1)%P.length],p3=P[(i+2)%P.length];
      if(i===0)d.push(`M${p1[0]},${p1[1]}`);
      const c1x=p1[0]+(p2[0]-p0[0])/6,c1y=p1[1]+(p2[1]-p0[1])/6;
      const c2x=p2[0]-(p3[0]-p1[0])/6,c2y=p2[1]-(p3[1]-p1[1])/6;
      d.push(`C${c1x},${c1y} ${c2x},${c2y} ${p2[0]},${p2[1]}`);
    } d.push('Z'); return d.join(' ');
  }
  function ribbon(pts,w0=3,w1=.9){
    if(pts.length<2)return''; const L=[],R=[];
    for(let i=0;i<pts.length;i++){
      const p=pts[i],pr=pts[i-1]||p,nx=pts[i+1]||p,vx=nx.x-pr.x,vy=nx.y-pr.y,len=Math.hypot(vx,vy)||1;
      const nX=-vy/len,nY=vx/len,t=i/(pts.length-1),w=w0*(1-t)+w1*t;
      L.push([p.x+nX*w,p.y+nY*w]); R.push([p.x-nX*w,p.y-nY*w]);
    }
    const all=L.concat(R.reverse()); let d=`M${all[0][0]},${all[0][1]}`; for(let i=1;i<all.length;i++) d+=` L${all[i][0]},${all[i][1]}`; return d+' Z';
  }
  function smoothD(pts){ if(pts.length<2) return ''; let d=`M${pts[0].x},${pts[0].y}`;
    for(let i=1;i<pts.length-1;i++){const p1=pts[i],p2=pts[i+1],mx=(p1.x+p2.x)/2,my=(p1.y+p2.y)/2;
      d+=` Q ${p1.x},${p1.y} ${mx},${my}`;} return d; }

  function toEdge(W,H,origin,step,jitter,startA,maxSteps,margin){
    let {x,y}=origin, a=(startA==null)?Math.random()*Math.PI*2:startA;
    const pts=[{x,y}], bias=Math.atan2(y<H/2?-1:1, x<W/2?-1:1); a=(a*3+bias)/4;
    let s=0; while(inB(W,H,x,y,margin)&&s<maxSteps){ a+=R(-jitter,jitter);
      const p=stepFn(W,H,margin,x,y,a,step); x=p.x;y=p.y; pts.push({x,y}); s++; if(!inB(W,H,x,y,margin))break; }
    const last=pts[pts.length-1], toL=last.x-margin, toR=(W-margin)-last.x, toT=last.y-margin, toB=(H-margin)-last.y;
    const m=Math.min(toL,toR,toT,toB); if(m===toL)last.x=margin; if(m===toR)last.x=W-margin; if(m===toT)last.y=margin; if(m===toB)last.y=H-margin;
    return pts;
  }
  function branchToEdge(W,H,anchor,prev,maxSteps,margin){
    const st=R(14,20), jit=Math.PI/8, dx=anchor.x-(prev?.x??anchor.x), dy=anchor.y-(prev?.y??anchor.y);
    let a=Math.atan2(dy,dx)+(Math.random()<.5?1:-1)*(Math.PI/2+R(-.6,.6));
    const bias=Math.atan2(anchor.y<H/2?-1:1, anchor.x<W/2?-1:1); a=(a*3+bias)/4;
    let x=anchor.x,y=anchor.y, pts=[{x,y}], s=0;
    while(inB(W,H,x,y,margin)&&s<maxSteps){ a+=R(-jit,jit); const p=stepFn(W,H,margin,x,y,a,st);
      x=p.x;y=p.y; pts.push({x,y}); s++; if(!inB(W,H,x,y,margin))break; }
    const last=pts[pts.length-1], toL=last.x-margin, toR=(W-margin)-last.x, toT=last.y-margin, toB=(H-margin)-last.y;
    const m=Math.min(toL,toR,toT,toB); if(m===toL)last.x=margin; if(m===toR)last.x=W-margin; if(m===toT)last.y=margin; if(m===toB)last.y=H-margin;
    return pts;
  }

  function drawHeader(){
    const W = mount.clientWidth;
    const H = mount.clientHeight;
    if(!W||!H) return; // header not laid out yet
    const {svg,LAYER_BRANCH,LAYER_MAIN,LAYER_PULSE,LAYER_SOMA} = buildSVG(W,H);

    // somas in header area
    const somas=[];
    for(let i=0;i<CFG.somaCount;i++){
      const cx=R(80,W-80), cy=R(60,H-60);
      const soma=document.createElementNS(svg.namespaceURI,'path');
      soma.setAttribute('d',somaPath(cx,cy,R(14,22),Math.floor(R(5,8)),.4));
      soma.setAttribute('class','soma'); LAYER_SOMA.appendChild(soma);
      const core=document.createElementNS(svg.namespaceURI,'path');
      core.setAttribute('d',somaPath(cx,cy,R(9,12),Math.floor(R(6,9)),.55));
      core.setAttribute('class','soma-core'); LAYER_SOMA.appendChild(core);
      somas.push({x:cx,y:cy});
    }

    const all=[];
    somas.forEach(o=>{
      const count = CFG.minWalks + (Math.random()<CFG.extraWalkProb?1:0);
      const angs = angles(count, Math.PI/5);
      angs.forEach(a=>{
        const bb = toEdge(W,H,o,CFG.step,CFG.jitter,a,CFG.maxMain,CFG.margin);
        all.push(bb);
        const outer=document.createElementNS(svg.namespaceURI,'path'); outer.setAttribute('d',ribbon(bb,R(2,3.5),R(.7,1)));
        outer.setAttribute('class','fiber'); LAYER_MAIN.appendChild(outer);
        const inner=document.createElementNS(svg.namespaceURI,'path'); inner.setAttribute('d',ribbon(bb,R(1,1.8),R(.5,.8)));
        inner.setAttribute('class','fiber inner'); LAYER_MAIN.appendChild(inner);
        const pulse=document.createElementNS(svg.namespaceURI,'path'); pulse.setAttribute('d',smoothD(bb));
        pulse.setAttribute('class','pulsePath'); pulse.style.animationDuration = CFG.pulseSec+'s'; LAYER_PULSE.appendChild(pulse);
      });
    });

    for(let k=0;k<CFG.branches;k++){
      const bb=all[Math.floor(Math.random()*all.length)];
      const idx=Math.floor(R(2, Math.min(bb.length-4, bb.length*0.7)));
      const anchor=bb[idx], prev=bb[idx-1];
      const pts=branchToEdge(W,H,anchor,prev,CFG.maxBranch,CFG.margin);

      const o=document.createElementNS(svg.namespaceURI,'path'); o.setAttribute('d',ribbon(pts,R(2,3),R(.4,.8)));
      o.setAttribute('class','fiber'); LAYER_BRANCH.appendChild(o);
      const i=document.createElementNS(svg.namespaceURI,'path'); i.setAttribute('d',ribbon(pts,R(1.2,2),R(.3,.6)));
      i.setAttribute('class','fiber inner'); LAYER_BRANCH.appendChild(i);

      const p=document.createElementNS(svg.namespaceURI,'path'); p.setAttribute('d',smoothD(pts)); p.setAttribute('class','pulsePath');
      p.style.animationDuration=(CFG.pulseSec*.9)+'s'; LAYER_PULSE.appendChild(p);
    }
  }

  // draw once, and on resize (debounced) to fit header size
  let rid; const onResize=()=>{ cancelAnimationFrame(rid); rid=requestAnimationFrame(drawHeader); };
  window.addEventListener('resize', onResize, {passive:true});
  // header might not have height until layout; draw after load
  window.addEventListener('load', drawHeader);
})();
</script>
</body>
</html>

